\begin{section}

1. Code hoisting in adjacent blocks in a diamond/triangle like structure.
2. O(n) Algorithm.
3. Hoisting equivalent computations in non-sibling BBs.
4. Hoisting across switch blocks.
5. Hoisting to improve PRE.
6. Hoisting to reduce critical path in OoO execution.
7. Ranking/Wavefront algorithm to hoist across switch blocks.

Global code motion.
 bb1: b = ...
 bb2: c = ...
 bb3: a = b + c (to be moved to b5)
 bb4: ... = a
 old-live-range = distance(bb1,bb3) + distance(bb2,bb3) + distance (bb3,bb4)
 new-live-rance = distance(bb1,bb5) + distance(bb2,bb5) + distance (bb5,bb4)
 distance(bbx, bby) = total instruction count in the path from bbx to bby
 If the new live-range is less than the old one it will be a good candidate
 for gcm. When both the ranges will be same:
  - It is a simple copy of kind a = b.
  - One of the operands is not a Instruction/Register.
  - In these cases we need to have some heuristic or we can ignore them.

 The decision for bb5 can be made by whether hoist/sink is beneficial.

 Loads can be moved early as long as there is load available in each branch
 or there is already a load/store from/to the same underlying object.
 Stores can be moved up if there is a store/load to/from the same object.
 The idea is to establish that the object has memory allocated to it.
 Moving load/store together may help with locality of reference.

 PRE via Global Value Numbering
 Remove redundant instructions which are:
  - Already available in the dominator.
  - Are in one of the sibling branches, i.e., the instruction is used at
    a point which shares a common dominator where all the use-operands
    are available.
 In some cases it is possible to generate redundancy by restructuring the code
 (Ref. Ras Bodik), but that I'll leave for the next iteration of this patch.


 Hoisting also reduces critical path length of execution in out of order machines (but not in sequential machines), by exposing ILP before the conditional where the instruction was hoisted. This feature has already been identified in the previous patch which improves ray-trace.
  
 Concerns:
 Safety of load instructions to be checked. We cannot hoist loads until all the paths in the parent BBs have the same load. This is to comply with C semantics, although I'm not sure about this yet.
 Finding a cost model in case optimistic hoisting does not give desired results.

It seems, code hoisting is beneficial in cases even if the computations are not redundant.
Say c = f(a, b) is an instruction. Hoisting up will reduce the liveness of registers a and b, but will only increase the liveness of c. So we gain 2:1 even when the computation is not redundant. For loads this is not the case because, load takes only one operand so the liveness remains the same, additionally hoisting too much loads can have adversely affect the cache behavior.
On the other hand sinking loads may improve the cache behavior, because we load as late as possible. But sinking computations may increase the live range.
We might want to to improve the code-hoisting to a global code motion algorithm.


\end{section}


