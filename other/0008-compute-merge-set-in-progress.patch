From 87446a3d976237a65e4b44b8db945c6a8bda372b Mon Sep 17 00:00:00 2001
From: hiraditya <hiraditya@gmail.com>
Date: Sat, 26 Nov 2016 05:24:36 -0600
Subject: [PATCH 08/12] compute merge set in progress

---
 include/llvm/Support/GenericDomTree.h      |   5 +-
 lib/Transforms/Scalar/GVNHoist.cpp         | 102 +++++++++++++----
 test/Transforms/GVNHoist/dj-edge-detect.ll | 174 ++++++++++++++---------------
 3 files changed, 171 insertions(+), 110 deletions(-)

diff --git a/include/llvm/Support/GenericDomTree.h b/include/llvm/Support/GenericDomTree.h
index 07a5343..a686e25 100644
--- a/include/llvm/Support/GenericDomTree.h
+++ b/include/llvm/Support/GenericDomTree.h
@@ -677,11 +677,12 @@ protected:
                 llvm::make_unique<DomTreeNodeBase<NodeT>>(BB, IDomNode))).get();
   }
 
-  NodeT *getIDom(NodeT *BB) const { return IDoms.lookup(BB); }
-
   void addRoot(NodeT *BB) { this->Roots.push_back(BB); }
 
 public:
+
+  NodeT *getIDom(NodeT *BB) const { return IDoms.lookup(BB); }
+
   /// updateDFSNumbers - Assign In and Out numbers to the nodes while walking
   /// dominator tree in dfs order.
   void updateDFSNumbers() const {
diff --git a/lib/Transforms/Scalar/GVNHoist.cpp b/lib/Transforms/Scalar/GVNHoist.cpp
index f931a5a..4261e47 100644
--- a/lib/Transforms/Scalar/GVNHoist.cpp
+++ b/lib/Transforms/Scalar/GVNHoist.cpp
@@ -191,6 +191,12 @@ public:
 typedef DenseMap<const BasicBlock *, bool> BBSideEffectsSet;
 typedef SmallVector<Instruction *, 4> SmallVecInsn;
 typedef SmallVectorImpl<Instruction *> SmallVecImplInsn;
+typedef SmallSet<BasicBlock *, 2> SmallSetBB;
+typedef DenseMap<BasicBlock *, SmallSetBB> MergeSetT;
+typedef SmallVector<BasicBlock *, 4> BBLevelKeyT;
+typedef DenseMap<unsigned, BBLevelKeyT> BBLevelT;
+typedef DenseMap<BasicBlock *, unsigned> DomLevelsT;
+typedef std::pair<BasicBlock *, BasicBlock *> EdgeT;
 
 static void combineKnownMetadata(Instruction *ReplInst, Instruction *I) {
   static const unsigned KnownIDs[] = {
@@ -201,6 +207,34 @@ static void combineKnownMetadata(Instruction *ReplInst, Instruction *I) {
   combineMetadata(ReplInst, I, KnownIDs);
 }
 
+void printBBLevels(const BBLevelT &BBLevels) {
+  for (const std::pair<unsigned, BBLevelKeyT> &P: BBLevels) {
+    dbgs() << "\nLevel: " << P.first << "\n";
+    for (const BasicBlock* BB: P.second)
+      dbgs() << *BB << "\n";
+  }
+}
+
+void printMergeSet(const MergeSetT &M) {
+  for (const std::pair<BasicBlock *, SmallSetBB> &P: M) {
+    dbgs() << "\nMergeSet of: " << P.first->getName() << ": ";
+    for (const BasicBlock* BB: P.second)
+      dbgs() << BB->getName() << ", ";
+  }
+}
+
+void printJEdges(const DenseSet<EdgeT> &Edges) {
+  for (const EdgeT & E: Edges)
+    dbgs() << "\nFound a JEdge: " << E.first->getName()
+           << " -> " << E.second->getName();
+}
+
+void printSmallSet(SmallSetBB &S) {
+  dbgs() << "\nPrinting SmallSet: ";
+  for (const auto& BB: S)
+    dbgs() << BB->getName() << ",";
+}
+
 // This pass hoists common computations across branches sharing common
 // dominator. The primary goal is to reduce the code size, and in some
 // cases reduce critical path (by exposing more ILP).
@@ -215,55 +249,81 @@ public:
         MaxNumberOfBBSInPath = -1;
   }
 
-  typedef SmallVector<const BasicBlock *, 4> BBLevelKeyT;
-  typedef DenseMap<unsigned, BBLevelKeyT> BBLevelT;
-  typedef std::pair<const BasicBlock *, const BasicBlock *> EdgeT;
-
-  void constructDJGraph(DenseMap<DomTreeNode *, unsigned> &DomLevels,
+  void constructDJGraph(DomLevelsT &DomLevels,
     DenseSet<EdgeT> &JEdges, BBLevelT &BBLevels) {
     for (auto DFI = df_begin(DT->getRootNode()),
          DFE = df_end(DT->getRootNode()); DFI != DFE; ++DFI) {
       unsigned l = DFI.getPathLength() - 1;
-      DomLevels[*DFI] = l;
-      const BasicBlock *BB = (*DFI)->getBlock();
+      BasicBlock *BB = (*DFI)->getBlock();
+      DomLevels[BB] = l;
       BBLevels[l].push_back(BB);
-      for (const BasicBlock *Succ : BB->getTerminator()->successors())
+      for (BasicBlock *Succ : BB->getTerminator()->successors())
         if (!DT->properlyDominates(BB, Succ)) {
           JEdges.insert(std::make_pair(BB, Succ));
-          //llvm_unreachable("testcase");
         }
     }
   }
 
-  void printBBLevels(const BBLevelT &BBLevels) {
-    for (const std::pair<unsigned, BBLevelKeyT> &P: BBLevels) {
-      dbgs() << "\nLevel: " << P.first << "\n";
-      for (const BasicBlock* BB: P.second)
-        dbgs() << *BB << "\n";
+  // Return true if S1 is a subset of S2.
+  bool subset(const SmallSetBB &S1, const SmallSetBB &S2) {
+    if (S2.size() < S1.size())
+      return false;
+    for (BasicBlock *BB : S1) {
+      if (!S2.count(BB))
+        return false;
     }
+    return true;
   }
 
-  unsigned constructMergeSet() {
-    DenseMap<DomTreeNode *, unsigned> DomLevels;
+  bool constructMergeSet(MergeSetT &MergeSet) {
+    bool Repeat = false;
+    DomLevelsT DomLevels;
     BBLevelT BBLevels;
     DenseSet<EdgeT> JEdges;
+    DenseSet<EdgeT> VJEdges;
     constructDJGraph(DomLevels, JEdges, BBLevels);
     printBBLevels(BBLevels);
+    printJEdges(JEdges);
     for (std::pair<unsigned ,BBLevelKeyT> &P: BBLevels) {
-      for (const BasicBlock* BB: P.second) {
+      for (BasicBlock* BB: P.second) {
         for (auto PB = pred_begin(BB), PE = pred_end(BB);
              PB != PE; ++PB) {
-          if (JEdges.count(std::make_pair(*PB, BB))) {
-            dbgs() << "\nFound a JEdge: " << (*PB)->getName() << " -> " << BB->getName();
+          EdgeT Edge(*PB, BB);
+          if (JEdges.count(Edge) && !VJEdges.count(Edge)) {
+            VJEdges.insert(Edge); // Visit
+            BasicBlock *SNode = Edge.first;
+            BasicBlock *TNode = Edge.second;
+            BasicBlock *Tmp = SNode;
+            BasicBlock *INode = nullptr;
+            MergeSet[TNode].insert(TNode); // The target of JEdge.
+            while (DomLevels[Tmp] >= DomLevels[TNode]) {
+              MergeSet[Tmp].insert(MergeSet[TNode].begin(), MergeSet[TNode].end());
+              MergeSet[Tmp].insert(TNode);
+              INode = Tmp;
+              Tmp = DT->getIDom(Tmp);
+            }
+            for (auto PINode = pred_begin(INode), PENode = pred_end(INode);
+                 PINode != PENode; ++PINode) { // INode is an ancestor of SNode.
+              EdgeT Edge(*PINode, INode);
+              if (VJEdges.count(Edge)) {
+                assert (JEdges.count(Edge));
+                BasicBlock *SNode = *PINode;
+                // Check inconsistency.
+                if (!subset(MergeSet[SNode], MergeSet[INode]))
+                  Repeat = true;
+              }
+            }
           }
         }
       }
     }
-    return DomLevels.size() + JEdges.size();
+    return Repeat;
   }
 
   bool run(Function &F) {
-    constructMergeSet();
+    MergeSetT MergeSet;
+    while(constructMergeSet(MergeSet));
+    printMergeSet(MergeSet);
     VN.setDomTree(DT);
     VN.setAliasAnalysis(AA);
     VN.setMemDep(MD);
diff --git a/test/Transforms/GVNHoist/dj-edge-detect.ll b/test/Transforms/GVNHoist/dj-edge-detect.ll
index 8a854f3..cda29fc 100644
--- a/test/Transforms/GVNHoist/dj-edge-detect.ll
+++ b/test/Transforms/GVNHoist/dj-edge-detect.ll
@@ -1,97 +1,97 @@
 ; RUN: opt -S -gvn-hoist < %s | FileCheck %s
 
-; CHECK-LABEL: define void @music_task
-; CHECK: Found a JEdge: while.cond2.backedge -> while.cond2
-; CHECK: Found a JEdge: while.cond.loopexit -> while.cond
-; CHECK: Found a JEdge: sw.default -> while.cond2.backedge
-; CHECK: Found a JEdge: sw.bb13 -> while.cond2.backedge
-; CHECK: Found a JEdge: sw.bb7 -> while.cond2.backedge
-; CHECK: Found a JEdge: sw.bb -> while.cond2.backedge;
-
-%struct._MUSIC_OP_API_ = type { %struct._FILE_OPERATE_*, %struct.__MUSIC_API* }
-%struct._FILE_OPERATE_ = type { %struct._FILE_OPERATE_INIT_*, %struct._lg_dev_info_* }
-%struct._FILE_OPERATE_INIT_ = type { i32, i32, i32, i32, i32*, i8*, i32 }
-%struct._lg_dev_info_ = type { %struct.os_event, i32, i32, %struct._lg_dev_hdl_*, i8, i8, i8, i8, i8 }
-%struct.os_event = type { i8, i32, i8*, %union.anon }
-%union.anon = type { %struct.event_cnt }
-%struct.event_cnt = type { i16 }
-%struct._lg_dev_hdl_ = type { i8*, i8*, i8*, i8*, i8* }
-%struct.__MUSIC_API = type <{ i8*, i8*, i32, %struct._DEC_API, %struct._DEC_API_IO*, %struct._FS_BRK_POINT* }>
-%struct._DEC_API = type { %struct._DEC_PHY*, i8*, i8*, i8* (i8*)*, i32* (i8*)*, i8*, %struct._AAC_DEFAULT_SETTING, i32, i32, i8*, %struct.decoder_inf*, i32, i8, i8*, i8, i8* }
-%struct._DEC_PHY = type { i8*, %struct.__audio_decoder_ops*, i8*, %struct.if_decoder_io, %struct.if_dec_file*, i8*, i32 (i8*)*, i32, i8, %struct.__FF_FR }
-%struct.__audio_decoder_ops = type { i8*, i32 (i8*, %struct.if_decoder_io*, i8*)*, i32 (i8*)*, i32 (i8*, i32)*, %struct.decoder_inf* (i8*)*, i32 (i8*)*, i32 (i8*)*, i32 (...)*, i32 (...)*, i32 (...)*, void (i8*, i32)*, void (i8*, i32, i8*, i32)*, i32 (i8*, i32, i8*)* }
-%struct.if_decoder_io = type { i8*, i32 (i8*, i32, i8*, i32, i8)*, i32 (i8*, i32, i8*)*, void (i8*, i8*, i32)*, i32 (i8*)*, i32 (i8*, i32, i32)* }
-%struct.if_dec_file = type { i32 (i8*, i8*, i32)*, i32 (i8*, i32, i32)* }
-%struct.__FF_FR = type { i32, i32, i8, i8, i8 }
-%struct._AAC_DEFAULT_SETTING = type { i32, i32, i32 }
-%struct.decoder_inf = type { i16, i16, i32, i32 }
-%struct._DEC_API_IO = type { i8*, i8*, i16 (i8*, i8*, i16)*, i32 (i8*, i8, i32)*, i32 (%struct.decoder_inf*, i32)*, %struct.__OP_IO, i32, i32 }
-%struct.__OP_IO = type { i8*, i8* (i8*, i8*, i32)* }
-%struct._FS_BRK_POINT = type { %struct._FS_BRK_INFO, i32, i32 }
-%struct._FS_BRK_INFO = type { i32, i32, [8 x i8], i8, i8, i16 }
-
-@.str = external hidden unnamed_addr constant [10 x i8], align 1
-
-define void @music_task(i8* nocapture readnone %p) local_unnamed_addr {
-entry:
-  %mapi = alloca %struct._MUSIC_OP_API_*, align 8
-  %0 = bitcast %struct._MUSIC_OP_API_** %mapi to i8*
-  br label %while.cond
-
-while.cond.loopexit:                              ; preds = %while.cond2
-  br label %while.cond
-
-while.cond:                                       ; preds = %while.cond.loopexit, %entry
-  %1 = load %struct._MUSIC_OP_API_*, %struct._MUSIC_OP_API_** %mapi, align 8, !tbaa !1
- %call1 = call i32 @music_play_api(i8* %0)
-  br label %while.cond2
-
-while.cond2:                                      ; preds = %while.cond2.backedge, %while.cond
-  %err.0 = phi i32 [ %call1, %while.cond ], [ %err.0.be, %while.cond2.backedge ]
-  switch i32 %err.0, label %sw.default [
-    i32 0, label %while.cond.loopexit
-    i32 35, label %sw.bb
-    i32 11, label %sw.bb7
-    i32 12, label %sw.bb13
+; ModuleID = '<stdin>'
+source_filename = "<stdin>"
+
+; CHECK: Found a JEdge: bb18 -> bb6
+; CHECK: Found a JEdge: bb2 -> bb3
+; CHECK: Found a JEdge: bb15 -> bb18
+; CHECK: Found a JEdge: bb13 -> bb18
+; CHECK: Found a JEdge: bb10 -> bb18
+; CHECK: Found a JEdge: bb8 -> bb18
+
+%0 = type { %1*, %8* }
+%1 = type { %2*, %3* }
+%2 = type { i32, i32, i32, i32, i32*, i8*, i32 }
+%3 = type { %4, i32, i32, %7*, i8, i8, i8, i8, i8 }
+%4 = type { i8, i32, i8*, %5 }
+%5 = type { %6 }
+%6 = type { i16 }
+%7 = type { i8*, i8*, i8*, i8*, i8* }
+%8 = type <{ i8*, i8*, i32, %9, %17*, %19* }>
+%9 = type { %10*, i8*, i8*, i8* (i8*)*, i32* (i8*)*, i8*, %15, i32, i32, i8*, %16*, i32, i8, i8*, i8, i8* }
+%10 = type { i8*, %11*, i8*, %12, %13*, i8*, i32 (i8*)*, i32, i8, %14 }
+%11 = type { i8*, i32 (i8*, %12*, i8*)*, i32 (i8*)*, i32 (i8*, i32)*, %16* (i8*)*, i32 (i8*)*, i32 (i8*)*, i32 (...)*, i32 (...)*, i32 (...)*, void (i8*, i32)*, void (i8*, i32, i8*, i32)*, i32 (i8*, i32, i8*)* }
+%12 = type { i8*, i32 (i8*, i32, i8*, i32, i8)*, i32 (i8*, i32, i8*)*, void (i8*, i8*, i32)*, i32 (i8*)*, i32 (i8*, i32, i32)* }
+%13 = type { i32 (i8*, i8*, i32)*, i32 (i8*, i32, i32)* }
+%14 = type { i32, i32, i8, i8, i8 }
+%15 = type { i32, i32, i32 }
+%16 = type { i16, i16, i32, i32 }
+%17 = type { i8*, i8*, i16 (i8*, i8*, i16)*, i32 (i8*, i8, i32)*, i32 (%16*, i32)*, %18, i32, i32 }
+%18 = type { i8*, i8* (i8*, i8*, i32)* }
+%19 = type { %20, i32, i32 }
+%20 = type { i32, i32, [8 x i8], i8, i8, i16 }
+
+@global = external hidden unnamed_addr constant [10 x i8], align 1
+
+define void @ham(i8* nocapture readnone %arg) local_unnamed_addr {
+bb:
+  %tmp = alloca %0*, align 8
+  %tmp1 = bitcast %0** %tmp to i8*
+  br label %bb3
+
+bb2:                                              ; preds = %bb6
+  br label %bb3
+
+bb3:                                              ; preds = %bb2, %bb
+  %tmp4 = load %0*, %0** %tmp, align 8, !tbaa !0
+  %tmp5 = call i32 @quux(i8* %tmp1)
+  br label %bb6
+
+bb6:                                              ; preds = %bb18, %bb3
+  %tmp7 = phi i32 [ %tmp5, %bb3 ], [ %tmp19, %bb18 ]
+  switch i32 %tmp7, label %bb15 [
+    i32 0, label %bb2
+    i32 35, label %bb8
+    i32 11, label %bb10
+    i32 12, label %bb13
   ]
 
-sw.bb:                                            ; preds = %while.cond2
-  %a = load %struct._MUSIC_OP_API_*, %struct._MUSIC_OP_API_** %mapi, align 8, !tbaa !1
- br label %while.cond2.backedge
+bb8:                                              ; preds = %bb6
+  %tmp9 = load %0*, %0** %tmp, align 8, !tbaa !0
+  br label %bb18
 
-sw.bb7:                                           ; preds = %while.cond2
-  %v = load %struct._MUSIC_OP_API_*, %struct._MUSIC_OP_API_** %mapi, align 8, !tbaa !1
- %call12 = call i32 @music_play_api(i8* %0)
-  br label %while.cond2.backedge
+bb10:                                             ; preds = %bb6
+  %tmp11 = load %0*, %0** %tmp, align 8, !tbaa !0
+  %tmp12 = call i32 @quux(i8* %tmp1)
+  br label %bb18
 
-sw.bb13:                                          ; preds = %while.cond2
- %call18 = call i32 @music_play_api(i8* %0)
-  br label %while.cond2.backedge
+bb13:                                             ; preds = %bb6
+  %tmp14 = call i32 @quux(i8* %tmp1)
+  br label %bb18
 
-sw.default:                                       ; preds = %while.cond2
-  %lk = load %struct._MUSIC_OP_API_*, %struct._MUSIC_OP_API_** %mapi, align 8, !tbaa !1
-  %call19 = call i32 @music_play_api(i8* null)
-  br label %while.cond2.backedge
+bb15:                                             ; preds = %bb6
+  %tmp16 = load %0*, %0** %tmp, align 8, !tbaa !0
+  %tmp17 = call i32 @quux(i8* null)
+  br label %bb18
 
-while.cond2.backedge:                             ; preds = %sw.default, %sw.bb13, %sw.bb7, %sw.bb
-  %err.0.be = phi i32 [ %call19, %sw.default ], [ %call18, %sw.bb13 ], [ %call12, %sw.bb7 ], [ 0, %sw.bb ]
-  br label %while.cond2
+bb18:                                             ; preds = %bb15, %bb13, %bb10, %bb8
+  %tmp19 = phi i32 [ %tmp17, %bb15 ], [ %tmp14, %bb13 ], [ %tmp12, %bb10 ], [ 0, %bb8 ]
+  br label %bb6
 }
 
-declare void @llvm.lifetime.start(i64, i8* nocapture)
-declare i32 @music_decoder_init(%struct._MUSIC_OP_API_**)
-declare i32 @music_play_api(i8*)
-declare i32 @printf(i8* nocapture readonly, ...)
-
-!0 = !{!"clang version 4.0.0 "}
-!1 = !{!2, !2, i64 0}
-!2 = !{!"any pointer", !3, i64 0}
-!3 = !{!"omnipotent char", !4, i64 0}
-!4 = !{!"Simple C/C++ TBAA"}
-!5 = !{!6, !2, i64 8}
-!6 = !{!"_MUSIC_OP_API_", !2, i64 0, !2, i64 8}
-!7 = !{!8, !9, i64 16}
-!8 = !{!"__MUSIC_API", !2, i64 0, !2, i64 8, !9, i64 16, !10, i64 20, !2, i64 140, !2, i64 148}
-!9 = !{!"int", !3, i64 0}
-!10 = !{!"_DEC_API", !2, i64 0, !2, i64 8, !2, i64 16, !2, i64 24, !2, i64 32, !2, i64 40, !11, i64 48, !9, i64 60, !9, i64 64, !2, i64 72, !2, i64 80, !9, i64 88, !3, i64 92, !2, i64 96, !3, i64 104, !2, i64 112}
-!11 = !{!"_AAC_DEFAULT_SETTING", !9, i64 0, !9, i64 4, !9, i64 8}
+; Function Attrs: argmemonly nounwind
+declare void @llvm.lifetime.start(i64, i8* nocapture) #0
+
+declare i32 @zot(%0**)
+
+declare i32 @quux(i8*)
+
+declare i32 @wombat(i8* nocapture readonly, ...)
+
+attributes #0 = { argmemonly nounwind }
+
+!0 = !{!1, !1, i64 0}
+!1 = !{!"any pointer", !2, i64 0}
+!2 = !{!"omnipotent char", !3, i64 0}
+!3 = !{!"Simple C/C++ TBAA"}
-- 
2.5.0

