\documentclass{beamer}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{graphviz}
\usepackage{tikz}
\usepackage{dot2texi}
\usepackage{listings}
\usepackage{adjustbox}

\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

\begin{document}
\def \GVN {GVN}

\title{\GVN{}-Hoist: Hoisting Computations from Branches}
\author{Sebastian Pop and Aditya Kumar}
\institute{SARC: Samsung Austin R\&D Center}
\date{November 3, 2016}

\definecolor{myblue}{rgb}{0.0, 0.0, 0.5}
\definecolor{myred}{rgb}{0.5, 0.0, 0.0}
\definecolor{mygreen}{rgb}{0.0, 0.5, 0.0}
\lstset{language=C++,
  basicstyle=\ttfamily,
  keywordstyle=\color{myblue}\ttfamily,
  stringstyle=\color{myred}\ttfamily,
  commentstyle=\color{mygreen}\ttfamily,
  morecomment=[l][\color{magenta}]{\#}
}
\addtobeamertemplate{navigation symbols}{}{%
    \usebeamerfont{footline}%
    \usebeamercolor[fg]{footline}%
    \hspace{1em}%
    \insertframenumber/\inserttotalframenumber
}

\frame{\titlepage}

\frame{\frametitle{CFGSimplify's code hoisting}
  \begin{itemize}
  \item hoists computations at the beginning of BB
  \item stops at first difference
  \item very fast: disabling slows the compiler: $1688 \to 1692$ Bn insns
  \end{itemize}
}

\begin{frame}[fragile]{CFGSimplify limits}
  \begin{lstlisting}
  if (inv >= 0) {
    tmin = (min - a) * inv;
    tmax = (max - a) * inv;
  } else {
    tmin = (max - a) * inv;
    tmax = (min - a) * inv;
  }
  \end{lstlisting}

  $\hspace{2cm}\Big\downarrow$

  \begin{lstlisting}
  x = (min - a) * inv;
  y = (max - a) * inv;
  if (inv >= 0) {
    tmin = x;
    tmax = y;
  } else {
    tmin = y;
    tmax = x;
  }
  \end{lstlisting}
\end{frame}

\frame{\frametitle{\GVN{}-Hoist: Hoisting Computations from Branches}
  \begin{itemize}
    \item identifies identical computations in a function
    \item hoist identical computations to a common dominator
    \item reduces code size
    \item reduces critical path length by exposing more ILP
  \end{itemize}
}


\frame{\frametitle{Optimistic \GVN{}-hoist Algorithm}
  \begin{itemize}
  \item compute value number of scalars, loads, stores, calls
  \item compute insertion points of each type of instructions
  \item hoist expressions and propagate changes by updating SSA
  \end{itemize}
}

\begin{frame}[fragile]{Value Numbering}

  \begin{columns}[T,onlytextwidth] % align columns
    \column{.3\textwidth}
    \begin{block}{\small Simple program}
      \begin{lstlisting}
a = x + y
b = x + 1
c = y + 1
d = b + c
e = a + 2
      \end{lstlisting}
    \end{block}
    \pause
    \column{.2\textwidth}
    \begin{center}
      \vspace{1cm}
      $\rightarrow$
    \end{center}
    \column{.3\textwidth}
    \begin{block}{\small Value Numbering}
      \begin{lstlisting}
a -> 1
b -> 2
c -> 3
d -> 4
e -> 4
      \end{lstlisting}
    \end{block}
  \end{columns}

\end{frame}

\frame{\frametitle{\GVN{}-Hoist: Algorithm-collecting value numbers}
  \begin{itemize}
  \item scalars: use the existing GVN infrastructure
  \item loads: VN the pointer operand
  \item stores: VN the pointer operand and the value being stored
  \item calls: as stores, loads, or scalars (following side effects)
  \end{itemize}
  current GVN not accurate for loads and stores: use ad-hoc change
}

\frame{\frametitle{\GVN{}-Hoist: Algorithm-compute insertion points}
  Insertion Point: A location where all the operands are either available
    or, can be made available.

  \begin{itemize}
  \item Compute a common insertion point for a set of instructions having the same GVN
    (Similar to VBEs but not as strict)
  \item Partition the candidates into a smaller set of hoistable candidates when
    no common insertion points can be found
  \end{itemize}
}

\frame{\frametitle{\GVN{}-Hoist: Algorithm-hoist expressions}
  \begin{itemize}
  \item scalars: just move one of the instructions to the hoisting point and remove others; update SSA
  \item loads and stores: try to make geps available, then hoist; update SSA and memory SSA
  \end{itemize}
}

\newlength\someheight
\setlength\someheight{4cm}

\begin{frame}[fragile]{Example}
\begin{adjustbox}{width=\textwidth,height=\someheight,keepaspectratio}
\begin{lstlisting}
define float @f(float %d, float %min, float %max, float %a) {
entry:
  %div = fdiv float 1.000000e+00, %d
  %cmp = fcmp oge float %div, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %sub = fsub float %min, %a
  %mul = fmul float %sub, %div
  %sub1 = fsub float %max, %a
  %mul2 = fmul float %sub1, %div
  br label %if.end

if.else:                                          ; preds = %entry
  %sub3 = fsub float %max, %a
  %mul4 = fmul float %sub3, %div
  %sub5 = fsub float %min, %a
  %mul6 = fmul float %sub5, %div
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %tmax.0 = phi float [ %mul2, %if.then ], [ %mul6, %if.else ]
  %tmin.0 = phi float [ %mul, %if.then ], [ %mul4, %if.else ]
  %add = fadd float %tmax.0, %tmin.0
  ret float %add
}
\end{lstlisting}
\end{adjustbox}
\end{frame}

\begin{frame}[fragile]{Example}
\begin{adjustbox}{width=\textwidth,height=\someheight,keepaspectratio}
\begin{lstlisting}
define float @f(float %d, float %min, float %max, float %a) {
entry:
  %div = fdiv float 1.000000e+00, %d
  %cmp = fcmp oge float %div, 0.000000e+00
  %sub1 = fsub float %max, %a
  %sub = fsub float %min, %a
  %mul2 = fmul float %sub1, %div
  %mul = fmul float %sub, %div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %tmax.0 = phi float [ %mul2, %if.then ], [ %mul, %if.else ]
  %tmin.0 = phi float [ %mul, %if.then ], [ %mul2, %if.else ]
  %add = fadd float %tmax.0, %tmin.0
  ret float %add
}
\end{lstlisting}
\end{adjustbox}
\end{frame}


\frame{\frametitle{Cost models}
  \begin{itemize}
  \item limit the number of basic blocks in the path between initial position
    and the hoisting point
  \item limit the number of instructions between the initial position and the
    beginning of its basic block
  \item do not hoist GEPs
  \item limit the number of dependent instructions to be hoisted
  \end{itemize}
}

\frame{\frametitle{GVN hoisting}
  \begin{itemize}
  \item $1\%$ compile time overhead: $1678 \to 1692$ Bn insns
  \item more hoists than CFG-simplify: $15048 \to 25318$
  \end{itemize}

  \begin{center}
    \begin{tabular}{|l|c|}
      \hline
      Scalars hoisted      & 8960  \\\hline
      Scalars removed      & 11940 \\\hline
      Loads hoisted        & 16301 \\\hline
      Loads removed        & 22690 \\\hline
      Stores hoisted       & 50    \\\hline
      Stores removed       & 50    \\\hline
      Calls hoisted        & 7     \\\hline
      Calls removed        & 7     \\\hline
      Total Instructions hoisted & 25318 \\\hline
      Total Instructions removed & 34687 \\\hline
    \end{tabular}
  \end{center}
}

\frame{\frametitle{Code size reduction}
  \begin{center}
    \begin{tabular}{|l|c|}
      \hline
      Code-size metric  (.text)                   & Number   \\\hline
      Total  benchmarks                           & 497      \\\hline
      Total  gained in size                       & 39       \\\hline
      Total  decrease in size                     & 58       \\\hline
      Median decrease in size                     & 2.9\%    \\\hline
      Median increase in size                     & 2.4\%    \\\hline
    \end{tabular}
  \end{center}
}

\end{document}
